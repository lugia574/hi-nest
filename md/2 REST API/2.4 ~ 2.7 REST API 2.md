## 2.4 DTOs and Validation part One

```ts
  create(movieData) {
    this.movies.push({
      id: this.movies.length + 1,
      ...movieData,
    });
  }

  update(id: string, updateData) {
    const movie = this.getOne(id);
    this.deleteOne(id);
    this.movies.push({ ...movie, ...updateData });
  }
```

UpdateData 랑 MovieData 한태 타입을 부여 해야지

영화 데이터에 유효성 검사가 가능하겠지

그러기 위해서는 **DTO** 를 만들어야해

DTO 는 `Data Transfer Object` 의 약자로 데이터 전송 객체임

movies 폴더에 dto 폴더를 만들어주고

`create-movie.dto.ts` 라 짓자

```ts
export class CreateMovieDto {
  readonly title: string;
  readonly year: number;
  readonly genres: string[];
}
```

읽기 전용으로 이렇게 해줘

이러면 끝일까? 아쉽게도 끝이 아님

이대로 적용하고 실행하면 이상한 값도 잘알 받아드림 ㅋ

제대로 적용하려면 NestJS 를 이용해야함

`main.ts` 에 파이프를 만들거임

```ts
async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.useGlobalPipes(new ValidationPipe());
  await app.listen(3000);
}
bootstrap();
```

요래 주고 유호성 해주는걸 설치 해줄꺼임

```
npm i class-validator class-transformer
```

class-validator, class-transformer 요거 2개 설치를 해주고

dto 가서 변수 앞에다가 데코레이터를 박아주면 됨

```ts
import { IsString, IsNumber } from 'class-validator';

export class CreateMovieDto {
  @IsString()
  readonly title: string;
  @IsNumber()
  readonly year: number;
  @IsString({ each: true })
  readonly genres: string[];
}
```

여기서 `each: true` 는 모든 요소를 하나씩 검사한다는거래

그럼 뭐 다른건 하나씩 안하나? 여튼

그리고 이걸 적용 해주면

`service`

```ts
  create(movieData: CreateMovieDto) {
    this.movies.push({
      id: this.movies.length + 1,
      ...movieData,
    });
  }

  update(id: string, updateData: CreateMovieDto) {
    const movie = this.getOne(id);
    this.deleteOne(id);
    this.movies.push({ ...movie, ...updateData });
  }
```

이렇게 된다~ 마찬가지로 controller 에도 적용해주면 된다~

`controller`

```ts
  @Post()
  create(@Body() movieData:CreateMovieDto) {
    return this.moviesService.create(movieData);
  }

  @Patch(':id')
  patch(@Param('id') movieId: string, @Body() updateData:CreateMovieDto) {
    return this.moviesService.update(movieId, updateData);
  }
```

자 이제 이상한 값을 준다면

```
{
  "wwww" : "!@!@222"
}
```

```
{
	"statusCode": 400,
	"message": [
		"title must be a string",
		"year must be a number conforming to the specified constraints",
		"each value in genres must be a string"
	],
	"error": "Bad Request"
}
```

이렇게 경고창을 뛰운다

이렇게 할 수 있는건

```ts
app.useGlobalPipes(new ValidationPipe());
```

얘가 있어서임

ValidationPipe 에 `whitelist` 라는 옵션이 있는데

true 로 설정하면 아무 decorator 도 없는 어떠한 property의 object 도 거름

`forbidNonWhitelisted` 옵션은 아예 리퀘스트 자체를 막아버릴는 옵션임

그리고 `transform` 이라는 옵션은 받은 자료를 해당 controller, service 에서 원하는 타입으로 변환해줌

transform을 쓰면 굳이 controller 에서 id 값 타입을 string 이라고 선언 해도 되고

service 에서 굳이 변환 해주는 코드를 써서 보낼 필요가 없음

다 적용해주면

```ts
import { ValidationPipe } from '@nestjs/common';
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.useGlobalPipes(
    new ValidationPipe({
      whitelist: true,
      forbidNonWhitelisted: true,
      transform: true,
    }),
  );
  await app.listen(3000);
}
bootstrap();
```

```ts
  @Get(':id')
  getOne(@Param('id') movieId: number): Movie {
    const movie = this.moviesService.getOne(movieId);
    return movie;
  }

  @Post()
  create(@Body() movieData: CreateMovieDto) {
    return this.moviesService.create(movieData);
  }

  @Delete(':id')
  remove(@Param('id') movieId: number) {
    return this.moviesService.deleteOne(movieId);
  }

  @Patch(':id')
  patch(@Param('id') movieId: number, @Body() updateData: CreateMovieDto) {
    return this.moviesService.update(movieId, updateData);
  }
```

```ts
  getOne(id: number): Movie {
    const movie = this.movies.find((movie) => movie.id === id);
    if (!movie) {
      throw new NotFoundException(
        `해당 영화는 찾을수 없습니다. ID ${id} is not found`,
      );
    }
    return movie;
  }

  deleteOne(id: number) {
    this.getOne(id);
    this.movies = this.movies.filter((movie) => movie.id !== +id);
  }

  create(movieData: CreateMovieDto) {
    this.movies.push({
      id: this.movies.length + 1,
      ...movieData,
    });
  }

  update(id: number, updateData: CreateMovieDto) {
    const movie = this.getOne(id);
    this.deleteOne(id);
    this.movies.push({ ...movie, ...updateData });
  }
```

이렇게 되겠음

이게 NestJS 의 좋은점임

Express 를 쓰면 혼자 다 박아놔야함

근데 NestJS 는 옵션 키면 됨

## 2.5 DTOs and Validation part Two
